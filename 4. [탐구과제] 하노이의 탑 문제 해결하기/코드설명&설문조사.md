# 미션 1-1
기둥 구조체, pole 3개를 선언한다
기둥 구조체에는 원판의 배열과 원판의 개수가 있다

  ## main()
    사용할 원판의 개수를 입력 받고 count에 저장한다
    pole 0번의 원판의 배열에 count부터 1까지 대입해준다
    원판의 개수를 count로 대입해준다
    printTower()를 실행한다
    프로그램을 종료한다

  ## printTower()
    첫번째 for문에는 "기둥 마다"를 담당한다
    각 기둥마다..

    원판이 없을때: x를 출력한다
    원판이 있을때: 두번째 for문을 실행한다

    두번째 for문에는 "원판 마다"를 담당하며 각 원판을 출력한다

# 미션 1-2
위와 비슷하지만 두 함수가 추가, 변경되었다

  ## main()
    사용할 원판의 개수를 입력 받고 count에 저장한다
    pole 0번의 원판의 배열에 count부터 1까지 대입해준다
    원판의 개수를 count로 대입해준다
    다른 pole의 원판의 개수를 0으로 각각 대입해준다
    printTower()를 실행한다

    다음의 무한반목문을 실행한다
      원판의 기둥을 옴기기 위해 from과 to를 입력받는다
      from과 to가 없는 원판을 가르키면 반복을 끝낸다
      아닐경우 move()에 from과 to를 주고 실행한다
      printTower()를 실행한다

    반복이 끝났을때, 프로그램을 종료한다

  ## move(int from, int to)
    from의 원판 개수가 1보다 작으면 원판이 없는 것이므로 0을 반환해 이동을 실패했음을 알린다
    to의 원판 개수가 0보다 클때 to의 가장 윗 원판이 from의 가장 윗 원판의 크기보다 작다면 기존의 원판이 새로 위에 쌓을 원판의 크기보다 작다는 것이므로 0을 반환해 이동을 실패했음을 알린다

    이동이 가능하다면...
    to기둥의 가장 윗 원판 위에 from기둥의 가장 윗 원판을 대입한다
    from기둥에 있던 가장 윗 원판을 지운다
    to기둥의 원판 개수를 1 증가한다
    from기둥의 원판 개수를 1 차감한다
    1을 반환해 이동에 성공하였음을 알린다

# 미션 1-3
위와 비슷하지만 두 함수가 추가, 변경되었고
이동 시도 횟수를 알려주는 try를 0으로 선언한다

  ## main()
  반복 할때마다 이동 시도 횟수를 1증가한다
  printfTower()를 실행한후 checkFinish()를 실행해 게임의 끝을 확인하고
  총 이동 시도 횟수를 출력한후
  끝일경우 반복을 끝낸다

  ## checkFinish()
  2번째 기둥을 제외한 나머지 기둥들의 원판의 개수가 1보다 작으면 2번째 기둥으로 원판이 전부 이동했다는 것이므로 1을 반환해 게임이 끝났음을 알린다
  아닐경우 0을 반환해 게임이 끝나지 않았음을 알린다

# 미션 2
위와 비슷하지만 두 함수가 추가, 변경되었다

  ## main()
  count를 입력받는것과 동시에 어디로 이동할지를 뜻하는 to도 같이 입력받는다
  반복문 대신 solve()에 count개의 원판을 0에서 1 혹은 2을 거쳐 to로 이동시키기 위해 count/0/to가 1보다 클때 1을 아니면 2를/to를 주고 실행한다
  printTower()를 실행한후 총 이동 시도 횟수를 출력하고 프로그램을 종료한다

  ## solve(int n, int from, int sub,  int to)
  이동 시도 횟수를 1 증가시킨다
  처리할 원판, n이 1개일 경우 move()를 실행해 to번째 기둥으로 옮기고 0을 반환해 끝낸다
  solve()를 실행해 아닐 경우 임시로 n - 1개를 sub번째 기둥으로 옮긴다
  move()를 실행해 남은 1개(가장 큰 원판을)를 to번째 기둥으로 옮긴다
  solve()를 실행해 sub번째 기둥에 임시로 옮겨둔 원판을 to번째 기둥으로 옮긴다

# 미션 3
위의 미션들과 코드가 매우 다르다

대기를 하기 위한 함수가 필요하고 개발 환경이 리눅스이므로 unistd.h를 참조한다
CUI를 위하여 문자열 작업이 필요함으로 string.h를 참조한다

메모리 용량 관리를 위해 원판의 최대 개수 제한과 기둥의 최대 개수 제한를 의미하는 상수, MAX_PLATE와 MAX_POLE을 각각 50, 10으로 선언한다
try와 limit를 선언한다, 각각 이동 시도 횟수와 마지막으로 사용할 수 있는 기둥의 index값을 의미한다

  ## main()
  count, moveTo, mode를 선언한다, 각각 원판의 개수, 이동할 기둥, 수동/자동 모드 선택을 의미한다
  CUI를 위해 문자열 str를 선언한다(코드 참고)
  
  str의 한글자 한글자 마다..
    그 글자를 출력한다
    만약 115번째 글자가 출력되었다면, count를 scanf로 물어본다
    만약 157번째 글자가 출력되었다면, moveTo를 scanf로 물어본다
    만약 223번째 글자가 출력되었다면, mode를 scanf로 물어본다
    아무것도 속하지 않으면, 0.01초를 대기한다 (쫌 짧은거 같아 보여도, konsole기준 한줄당 0.5초가 걸린다)
  사용 할 수 있는 마지막 기둥의 index값 limit를 사용자가 지정한 moveTo로 정해준다 (이 값을 증가시키면 사용할 수 있는 기둥의 개수가 늘어나 난이도가 더 쉬워진다)
  count와 moveTo를 검사해 MAX_PLATE와 MAX_POLE범위 안에 들어가는지 확인한다
  입력된 mode에 따라 manual()혹은 automatic을 count와 moveTo를 주고 실행한다
  입력이 에초에 잘못되었거나, 없는 모드라면 오류를 출력한다
  프로그램을 종료한다

  ## manual(int count, int moveTo)
  미션 1-1과 같이 0번째 기둥에 원판들을 큰 순서대로 넣는다
  각 기둥마다 원판의 개수를 대입해준다, 이때 0번째 기둥은 count로 나머지는 0으로 대입한다
  printTower()를 실행해 현재 상태를 보여준다

  다음의 무한 반복문을 실행한다..
    from과 to를 물어보고 입력받는다, "from기둥에서 to기둥으로 원판을 이동"을 의미한다
    move()를 from과 to를 주고 시도한후 결과가 실패(1)이라면, 이동할 수 없음을 출력
    checkFinish()를 count와 moveTo를 주고 시도한후 결과가 성공(1)이라면 반복문을 나간다

  반복문이 끝나면, 총 시도 횟수를 출력한후 프로그램을 종료한다

  ## automatic(int count, int moveTo)
  미션 1-1과 같이 0번째 기둥에 원판들을 큰 순서대로 넣는다
  각 기둥마다 원판의 개수를 대입해준다, 이때 0번째 기둥은 count로 나머지는 0으로 대입한다
  printTower()를 실행해 현재 상태를 보여준다

  solveProc()를 count와 0, 1, moveTo를 주고 실행한다, 이는 "count개의 원판을 moveTo개의 기둥 중 0번 기둥에서 1기둥을 통해 moveTo로 간다"를 의미한다

  총 시도 횟수를 출력한후 프로그램을 종료한다

  ## solveProc(int n, int from, int sub, int to)
  처리할 원판, n이 1개일 경우 move()를 실행해 to번째 기둥으로 옮기고 1초 대기한다
  아니라면
    solve()를 실행해 아닐 경우 임시로 n - 1개를 sub번째 기둥으로 옮긴다
    1초 대기한다
    move()를 실행해 남은 1개(가장 큰 원판을)를 to번째 기둥으로 옮긴다
    solve()를 실행해 sub번째 기둥에 임시로 옮겨둔 원판을 to번째 기둥으로 옮긴다

  ## move(int from, int to)
  from과 to가 없는 기둥을 가르키면 이동을 할 수 없으므로 1을 반환해 이동을 실패했음을 알린다
  from의 원판 개수가 1보다 작으면 원판이 없는 것이므로 1을 반환해 이동을 실패했음을 알린다
  to의 원판 개수가 0보다 클때 to의 가장 윗 원판이 from의 가장 윗 원판의 크기보다 작다면 기존의 원판이 새로 위에 쌓을 원판의 크기보다 작다는 것이므로 1을 반환해 이동을 실패했음을 알린다

  이동이 가능하다면...
  이동 횟수를 증가시키고 이동한 로그를 출력한다
  to기둥의 가장 윗 원판 위에 from기둥의 가장 윗 원판을 대입한다
  from기둥에 있던 가장 윗 원판을 지운다
  to기둥의 원판 개수를 1 증가한다
  from기둥의 원판 개수를 1 차감한다
  현재 상태를 printTower()를 실행해 출력한다
  0을 반환해 이동에 성공하였음을 알린다

  ## printTower()
  몇번째 이동인지 출력해준다
  첫번째 for문에는 "기둥 마다"(0 ~ limit + 1)를 담당한다
  각 기둥마다..

  원판이 없을때: x를 출력한다
  원판이 있을때: 두번째 for문을 실행한다

  두번째 for문에는 "원판 마다"를 담당하며 각 원판을 출력한다

  ## checkFinish(int count, int moveTo)
  이동하기로 한 기둥의 원판 개수가 처음의 전체 원판의 개수와 동일하면 이동하기로 한 기둥으로 원판이 전부 이동했다는 것이므로 게임이 끝남을 알리는 1을 반환한다
  아닐경우 게임이 안끝났다는 것을 알리는 0을 반환한다

# 설문조사
이 차시에서는 내가 배운 새로운 아이디어나 지식을 나의 경험과 연결해서 생각해 볼 수 있었다 --- 5
이 차시에서 배운 내용을 적용하거나 연습해 볼 수 있었다 --- 5
이 차시에서는 학습에 도움이 되는 다양한 자료와 사례들이 제시되었다 --- 3
이 차시에서는 실생활과 관련된 문제를 풀거나 과제를 수행할 수 있었다 --- 2
이 차시에서는 배운 내용이 나의 생활 속에서 어떻게 활용할 수 있을지 생각해 볼 수 있었다 --- 2
나는 이번 차시의 학습 주제가 좋았다 --- 4
이번 차시 E-Book에는 우리 사회와 일상생활에서 찾아볼 수 있는 여러 가지 예가 제시되어 있었다 --- 2
나는 이번 차시 E-Book에 제시된 내용과 과제들이 조금 어렵지만 해볼 만하다고 생각했다 --- 4
이번 차시 과제 작성 시 보고서(또는 산출물)에 포함할 주제, 내용, 탐구 방법 등을 선택할 수 있었기 때문에, 나는 선택한 활동과 결과에 대하여 책임을 느꼈다 --- 5
나는 이번 차시의 평가(점수)를 잘 받을 수 있을 것이다 --- 4
나는 이 주제에 대해 더 알고 싶다 --- 5
나는 앞으로도 이 주제와 관련된 공부를 좋아할 것 같다 --- 5
이 주제는 매우 흥미롭다 --- 5
나는 이 주제를 완벽하게 이해하고 싶다 --- 5
나는 이 주제에 완전히 집중했다 --- 5
나는 오늘 주제가 지루하게 느껴졌다 --- 2
나는 이 주제가 어려웠다 --- 4

1점: 전혀 그렇지 않다 / 2점: 그렇지 않다 / 3점: 보통이다 / 4점: 그렇다 / 5점: 매우 그렇다
